================================================================================
üì± COMPLETE GAME FLOW IN SHAHEEN APP (BAISHUN INTEGRATION)
================================================================================
Complete Step-by-Step Process from User Click to Game Exit
Last Updated: February 4, 2026
================================================================================


üéØ STEP 1: USER CLICKS "PLAY GAME" BUTTON
--------------------------------------------------------------------------------
Location: lib/view/screens/room/room_screen.dart

- User is in a room and clicks a game button
- App calls _openGameWebView() function
- Function signature:
  Future<void> _openGameWebView(
    BuildContext context,
    String url,
    String name, {
    Map<String, dynamic>? meta,
  })


üîë STEP 2: GENERATE ONE-TIME AUTHENTICATION CODE
--------------------------------------------------------------------------------
Frontend Action:
  - Calls ApiManager.requestGameCode() with userId and roomId
  
Backend Endpoint: server/php/request_game_code.php
  - Generates a JWT token with 30-second expiry
  - Token structure:
    {
      "userId": "user123",
      "roomId": "room456",
      "iat": 1234567890,
      "exp": 1234567920  // 30 seconds later
    }
  - Encodes as JWT using HS256 algorithm
  
Result:
  - code = one-time authentication token (e.g., "eyJhbGciOiJIUz...")
  
‚ö†Ô∏è CRITICAL: This code can ONLY be used ONCE by the game server!
             After use, it's stored in 'used_codes' table and rejected on reuse.


üåê STEP 3: PREPARE GAME URL WITH PARAMETERS
--------------------------------------------------------------------------------
App injects BAISHUN parameters into game URL query string:

Required Parameters:
  ‚Ä¢ appChannel     - Merchant channel (e.g., "mesh")
  ‚Ä¢ appId          - Merchant ID (configured by BAISHUN)
  ‚Ä¢ userId         - Player's database user_id
  ‚Ä¢ code           - One-time authentication token from Step 2
  ‚Ä¢ roomId         - Current room identifier
  
Optional Parameters:
  ‚Ä¢ gameMode       - "2" (half-screen/streamer) or "3" (full-screen/lobby)
  ‚Ä¢ language       - Language preference (e.g., "en", "ar", "zh")
  ‚Ä¢ gameId         - Which game is being played
  ‚Ä¢ gsp            - Game server node (101=Singapore, 201=Dubai, etc.)

Example Final URL:
  https://game.example.com/index.html?appChannel=mesh&appId=88888888
  &userId=338426830&code=eyJhbGci...&roomId=20240101&gameMode=3


üì± STEP 4: OPEN WEBVIEW WITH JSBRIDGE
--------------------------------------------------------------------------------
Technology: flutter_inappwebview

WebView Configuration:
  ‚úì JavaScript enabled (unrestricted)
  ‚úì DOM storage enabled
  ‚úì Mixed content allowed (HTTPS + HTTP)
  ‚úì Universal file access enabled (for local game packages)
  ‚úì Media playback autoplay enabled
  ‚úì Full-screen height

JavaScript Handlers Injected (Game ‚Üí App communication):

1. getConfig
   - Purpose: Game requests configuration data
   - Called by: window.flutter_inappwebview.callHandler('getConfig')
   - Response: Returns complete BAISHUN config JSON

2. destroy
   - Purpose: Game requests to close/exit
   - Called by: window.flutter_inappwebview.callHandler('destroy')
   - Action: Closes WebView and returns to room

3. gameRecharge
   - Purpose: User needs to purchase more coins
   - Called by: window.flutter_inappwebview.callHandler('gameRecharge')
   - Action: Opens Wallet/Store screen

4. gameLoaded
   - Purpose: Game finished loading
   - Called by: window.flutter_inappwebview.callHandler('gameLoaded')
   - Action: Hides loading spinner


üéÆ STEP 5: LOAD GAME IN WEBVIEW
--------------------------------------------------------------------------------
- WebView loads the game URL (can be local file:// or https://)
- Shows loading overlay: "Loading game..."
- Game HTML/JavaScript starts executing
- WebView console logs visible in debug mode


‚ö° STEP 6: GAME CALLS getConfig (GAME ‚Üí APP)
--------------------------------------------------------------------------------
Game JavaScript Action:
  window.flutter_inappwebview.callHandler('getConfig')
    .then(function(config) {
      console.log('Received config:', config);
      // Game uses config to initialize
    });

App Response Process:
  1. Receives getConfig call in JSBridge handler
  2. Generates a FRESH one-time code (each call needs new code!)
  3. Builds configuration JSON
  4. Returns to game

Configuration JSON Structure:
{
  "appChannel": "mesh",
  "appId": 88888888,
  "userId": "338426830",
  "code": "eyJhbGciOiJIUz...",      // ‚≠ê FRESH one-time code
  "roomId": "20240101",
  "gameMode": "3",                   // 1, 2, or 3 (never 0)
  "language": "en",
  "gameConfig": {
    "sceneMode": 0,                  // 0=default, 1=fresh, 2=middle, 3=prime
    "currencyIcon": "https://..."    // 60x60px icon
  },
  "gsp": 101,                        // Game server node
  "gameId": 1004
}

Alternative Flow (Some H5 Games):
  - Game may pass jsCallback name in params
  - App calls: jsCallback(config) directly via evaluateJavascript
  - Example: "getConfigCallback({...})"


üîê STEP 7: GAME SERVER GETS SESSION TOKEN (BAISHUN ‚Üí YOUR BACKEND)
--------------------------------------------------------------------------------
Endpoint: POST /v1/api/get_sstoken
File: server/php/get_sstoken.php

Request from BAISHUN Game Server:
{
  "app_id": 88888888,
  "user_id": "338426830",
  "code": "eyJhbGciOiJIUz...",       // From Step 6
  "signature_nonce": "5f0eb04d7603a9d8",
  "timestamp": 1682674598,
  "signature": "c62d04ebdb5100e475f45f5ebe8c64ee"
}

Your Backend Process:
  1. ‚úÖ Extract appKey from database (based on app_id)
  2. ‚úÖ Verify signature:
     - Calculate: md5(signatureNonce + AppKey + timestamp)
     - Must match provided signature
     - Timestamp must be within 15 seconds of current time
  
  3. ‚úÖ Check if code was already used:
     - Query: SELECT code FROM used_codes WHERE code = ?
     - If found ‚Üí ERROR 1001 "code_used"
  
  4. ‚úÖ Generate ss_token:
     - Random 32-character hex string
     - Validity: 7 days (expires_at = now + 7 days)
  
  5. ‚úÖ Store in database:
     - INSERT INTO sstokens(ss_token, user_id, app_id, expire_date)
  
  6. ‚úÖ Mark code as used:
     - INSERT INTO used_codes(code, used_at) VALUES (?, ?)
  
  7. ‚úÖ Return response:

Response to BAISHUN:
{
  "code": 0,
  "message": "succeed",
  "data": {
    "ss_token": "a1b2c3d4e5f6...",
    "expire_date": 1690934598000    // Milliseconds
  }
}

Error Codes:
  - 1001: Invalid request / code already used
  - 1003: Signature error
  - 1007: App not added

‚ö†Ô∏è CRITICAL: After this step, the 'code' is PERMANENTLY INVALID.
             Future getConfig calls MUST generate NEW codes.


üë§ STEP 8: GAME SERVER GETS USER INFO (BAISHUN ‚Üí YOUR BACKEND)
--------------------------------------------------------------------------------
Endpoint: POST /v1/api/get_user_info
File: server/php/get_user_info.php

Request from BAISHUN:
{
  "app_id": 88888888,
  "user_id": "338426830",
  "ss_token": "a1b2c3d4e5f6...",
  "client_ip": "192.168.1.100",
  "signature_nonce": "...",
  "timestamp": 1682674598,
  "signature": "..."
}

Your Backend Process:
  1. Verify signature
  2. Validate ss_token (check expiry)
  3. Query user data from database
  4. Return user information

Response to BAISHUN:
{
  "code": 0,
  "message": "succeed",
  "data": {
    "avatar_url": "https://example.com/avatar.jpg",
    "nickname": "PlayerOne",
    "currency_balance": 10000.00,    // ‚≠ê Current balance
    "level": 5,
    "user_type": 1,                  // Optional
    "can_convert": 0                 // Optional
  }
}

Game Action:
  - Displays user avatar and name
  - Shows current balance: 10,000 coins


‚úÖ STEP 9: GAME LOADED
--------------------------------------------------------------------------------
Game calls: window.flutter_inappwebview.callHandler('gameLoaded')

App Action:
  - Hides loading spinner
  - Logs: "[RoomScreen] Game loaded successfully"

User sees:
  - Fully loaded, interactive game
  - User balance displayed
  - Game is ready to play


üé≤ STEP 10: USER PLAYS GAME
--------------------------------------------------------------------------------
User Actions:
  - Places bets (e.g., -100 coins per spin)
  - Plays game rounds
  - Wins or loses

Game Tracking:
  - Each bet/win generates unique order_id
  - All transactions sent to backend in real-time
  - Game UI updates based on backend responses


üí∞ STEP 11: BALANCE UPDATES DURING GAMEPLAY (BAISHUN ‚Üí YOUR BACKEND)
--------------------------------------------------------------------------------
Endpoint: POST /v1/api/change_balance
File: server/php/change_balance.php

Triggered When:
  - User places a bet ‚Üí currency_diff = negative (e.g., -100)
  - User wins ‚Üí currency_diff = positive (e.g., +500)
  - Any game round completes

Request from BAISHUN:
{
  "app_id": 88888888,
  "user_id": "338426830",
  "ss_token": "a1b2c3d4e5f6...",
  "currency_diff": -100,              // ‚≠ê Amount change
  "game_id": 1004,
  "room_id": "20240101",
  "game_round_id": "rlmy01pq-cqkdd39jyrmz",
  "order_id": "2R5PHkx43UQPQydCrmI71BVqXwH",  // ‚≠ê Unique!
  "change_time_at": 1638845715,
  "diff_msg": "bet",                  // or "win", "lose", etc.
  "msg_type": "",                     // "" for real, "robot_bet" for fake
  "extend": "",                       // Additional data
  "currency_type": 0,                 // Optional
  "signature_nonce": "...",
  "timestamp": 1682674598,
  "signature": "..."
}

Your Backend Process (CRITICAL - Must be Atomic!):

  1. ‚úÖ Verify signature
  
  2. ‚úÖ Validate ss_token
     - Check expiry
     - Match user_id
  
  3. ‚úÖ CHECK IDEMPOTENCY (Prevents double-charging!)
     - Query: SELECT order_id FROM orders WHERE order_id = ?
     - If exists:
       ‚Üí Get current balance
       ‚Üí Return current balance immediately
       ‚Üí DO NOT process transaction again!
  
  4. ‚úÖ Start database transaction (for atomicity)
  
  5. ‚úÖ Lock user row (prevents concurrent modifications)
     - SELECT balance FROM users WHERE user_id = ? FOR UPDATE
  
  6. ‚úÖ Calculate new balance
     - newBalance = currentBalance + currency_diff
     - Example: 10000 + (-100) = 9900
  
  7. ‚úÖ Validate new balance
     - If newBalance < 0 ‚Üí ERROR 1008 "insufficient_assets"
     - ROLLBACK transaction
  
  8. ‚úÖ Update user balance
     - UPDATE users SET balance = ? WHERE user_id = ?
  
  9. ‚úÖ Record transaction
     - INSERT INTO orders(order_id, user_id, currency_diff, created_at)
  
  10. ‚úÖ Commit transaction
  
  11. ‚úÖ Return new balance

Response to BAISHUN:
{
  "code": 0,
  "message": "succeed",
  "unique_id": "1603289541785956352",  // Your transaction ID
  "data": {
    "currency_balance": 9900.00        // ‚≠ê New balance
  }
}

Example Transaction Flow:
  Starting Balance: 10,000

  Transaction 1: User bets 100
    - currency_diff: -100
    - New balance: 9,900
  
  Transaction 2: User wins 500
    - currency_diff: +500
    - New balance: 10,400
  
  Transaction 3: User bets 200
    - currency_diff: -200
    - New balance: 10,200

Error Codes:
  - 1001: Invalid request / token issues
  - 1003: Signature error
  - 1008: Insufficient balance (cannot bet more than owned)

‚ö†Ô∏è CRITICAL: Idempotency prevents disaster!
  If BAISHUN retries a request due to network timeout, the same order_id
  ensures the user isn't charged twice. ALWAYS check order_id first!


üí≥ STEP 12: USER RUNS OUT OF COINS (OPTIONAL)
--------------------------------------------------------------------------------
Triggered When:
  - User balance too low for minimum bet
  - User clicks recharge/purchase button in game

Game calls: window.flutter_inappwebview.callHandler('gameRecharge')

App Action:
  1. Opens WalletScreen
  2. User purchases coins (via in-app purchase or other methods)
  3. Backend updates user balance
  4. App returns to game

App ‚Üí Game Notification:
  After purchase, app calls:
  
  JavaScript:
    window.walletUpdate({
      "userId": "338426830"
    });
  
  Game Action:
    - Requests fresh user info from BAISHUN server
    - BAISHUN calls your /v1/api/get_user_info again
    - Game updates displayed balance


üö™ STEP 13: USER EXITS GAME
--------------------------------------------------------------------------------
Triggered By:
  - User clicks close/back button
  - Game completes and auto-closes
  - Game calls destroy handler

Game calls: window.flutter_inappwebview.callHandler('destroy')

App Process:
  1. Receives destroy callback
  
  2. Notifies lifecycle endpoint (optional):
     POST to game's close_url with:
     {
       "action": "close",
       "gameId": 1004,
       "roomId": "20240101",
       "userId": "338426830"
     }
  
  3. Loads blank page:
     controller.loadUrl(urlRequest: URLRequest(url: 'about:blank'))
  
  4. Closes bottom sheet modal:
     Navigator.of(context).pop()
  
  5. Releases WebView resources:
     - Clears cache
     - Removes JavaScript handlers
     - Nullifies controller reference

Logging:
  [RoomScreen] Game requested destroy
  [RoomScreen] Closing game WebView


üîÑ STEP 14: RETURN TO ROOM
--------------------------------------------------------------------------------
User is back in the room screen with:
  ‚úì Updated balance reflected throughout app
  ‚úì Game session completely terminated
  ‚úì Ready to play another game (process starts from Step 1)

Room UI Updates:
  - User's coin balance shows latest amount
  - No game state persists
  - Fresh session for next game


================================================================================
üîß CRITICAL BACKEND FILES
================================================================================

1. server/php/request_game_code.php
   Purpose: Generate one-time authentication codes
   Method: JWT token with 30-second expiry
   Security: HMAC SHA256 signing

2. server/php/get_sstoken.php
   Purpose: Exchange one-time code for session token
   Method: Validate code, generate ss_token, mark code used
   Security: Signature verification, one-time use enforcement

3. server/php/get_user_info.php
   Purpose: Provide user data to BAISHUN game server
   Method: Validate ss_token, return user profile + balance
   Security: Session token validation, timestamp verification

4. server/php/change_balance.php
   Purpose: Handle all game wins/losses
   Method: Atomic transactions with idempotency
   Security: Order ID tracking, row locking, balance validation

5. server/php/config.php
   Purpose: Database configuration and helper functions
   Contains: DB connection, signature verification, error response


================================================================================
üîí SECURITY FEATURES IMPLEMENTED
================================================================================

‚úÖ One-Time Codes
   - Each code expires in 30 seconds
   - Code can only be used ONCE
   - Stored in 'used_codes' table after use
   - Prevents replay attacks

‚úÖ Signature Verification
   - All BAISHUN requests include signature
   - Algorithm: md5(signatureNonce + AppKey + timestamp)
   - Timestamp validated (must be within 15 seconds)
   - Prevents request tampering

‚úÖ Idempotency
   - Same order_id returns same result
   - No double-charging even if request retried
   - Critical for network timeout scenarios

‚úÖ Transaction Locking
   - Database transactions prevent race conditions
   - Row-level locking (SELECT ... FOR UPDATE)
   - Ensures balance consistency

‚úÖ Session Tokens
   - 7-day validity period
   - Tied to specific user_id
   - Validated on every request
   - Prevents unauthorized access

‚úÖ Balance Validation
   - Negative balance prevented
   - Insufficient funds error returned
   - Transaction rolled back on failure


================================================================================
üìä DATABASE TABLES REQUIRED
================================================================================

1. users
   - user_id (VARCHAR, PRIMARY KEY)
   - balance (DECIMAL/INT)
   - nickname (VARCHAR)
   - avatar_url (VARCHAR)
   - level (INT)
   - created_at (TIMESTAMP)

2. sstokens
   - ss_token (VARCHAR, PRIMARY KEY)
   - user_id (VARCHAR)
   - app_id (INT)
   - expire_date (BIGINT) - milliseconds
   - created_at (TIMESTAMP)

3. used_codes
   - code (VARCHAR, PRIMARY KEY)
   - used_at (TIMESTAMP)

4. orders
   - order_id (VARCHAR, PRIMARY KEY)
   - user_id (VARCHAR)
   - currency_diff (INT)
   - game_id (INT)
   - room_id (VARCHAR)
   - created_at (TIMESTAMP)

5. apps (configuration)
   - app_id (INT, PRIMARY KEY)
   - app_key (VARCHAR) - for signature verification
   - app_channel (VARCHAR)


================================================================================
üêõ COMMON ISSUES & SOLUTIONS
================================================================================

Issue: "code_used" Error (1001)
Solution: Generate fresh code on each getConfig call
Code: await ApiManager.requestGameCode() on every getConfig request

Issue: "insufficient_assets" Error (1008)
Solution: User needs more coins - trigger gameRecharge
Action: Open WalletScreen, user purchases, call walletUpdate()

Issue: "signature_error" Error (1003)
Solution: Check AppKey configuration, verify timestamp is current
Debug: Log signatureNonce, timestamp, and calculated signature

Issue: Game shows blank screen
Solution: Check CORS headers, verify game URL is accessible
Debug: Check WebView console logs, network requests

Issue: Balance not updating in game
Solution: Call walletUpdate() after purchases
Code: controller.evaluateJavascript('walletUpdate({userId:"..."})')

Issue: Double-charging on network timeout
Solution: Idempotency already handled! Same order_id = safe
Verification: Check 'orders' table for duplicate order_id


================================================================================
üìû BAISHUN API ENDPOINTS (Your Backend Must Implement)
================================================================================

Required Endpoints:

POST /v1/api/get_sstoken
  - Exchange code for session token
  - Called by: BAISHUN game server
  - Frequency: Once per game session (or on token refresh)

POST /v1/api/get_user_info
  - Return user profile and balance
  - Called by: BAISHUN game server
  - Frequency: On game start, after walletUpdate

POST /v1/api/change_balance
  - Process bet/win transactions
  - Called by: BAISHUN game server
  - Frequency: Every game action (high volume!)

Optional Endpoints:

POST /v1/api/update_sstoken
  - Refresh expired session token
  - Called by: BAISHUN game server
  - Frequency: When ss_token near expiry

POST /v2/api/balance_info
  - Query user balance (for certain game categories)
  - Called by: BAISHUN game server
  - Frequency: On demand


================================================================================
üéÆ GAME MODES EXPLAINED
================================================================================

gameMode Values:
  "1" - Unknown/Special mode
  "2" - Half-screen (Streamer/Show mode)
        Game displays alongside streamer video
        Used in live streaming scenarios
  "3" - Full-screen (Game Lobby mode)
        Game takes entire screen
        Standard gameplay mode

‚ö†Ô∏è NEVER use gameMode "0" - it's invalid!
   The _validGameMode() function enforces this:
   - Returns "3" if mode is 0, null, or invalid
   - Returns "2" or "3" for valid modes


================================================================================
üåç LANGUAGE CODES (BAISHUN Multilingual)
================================================================================

Supported Languages:
  "0"  - Chinese (Simplified)
  "1"  - Chinese (Traditional)
  "2"  - English
  "3"  - Indonesian
  "4"  - Malay
  "5"  - Thai
  "6"  - Vietnamese
  "7"  - Arabic
  "8"  - Filipino
  "9"  - Portuguese
  "10" - Turkish
  "11" - Urdu
  "12" - Japanese
  "13" - Russian
  "14" - Spanish
  "38" - Hindi


================================================================================
üéØ GAME SERVER NODES (GSP Values)
================================================================================

Server Locations:
  101 - Singapore (Alibaba Cloud)
  201 - Dubai (AWS)
  301 - Silicon Valley (Alibaba Cloud)
  401 - Frankfurt (Alibaba Cloud)

Selection Criteria:
  - Choose based on user location
  - Lower latency = better experience
  - Singapore recommended for Asia/Middle East


================================================================================
üìù TESTING CHECKLIST
================================================================================

Frontend Testing:
  ‚òê Game opens in WebView
  ‚òê Loading spinner appears
  ‚òê getConfig returns valid JSON
  ‚òê gameLoaded callback hides spinner
  ‚òê destroy closes WebView properly
  ‚òê gameRecharge opens wallet

Backend Testing:
  ‚òê request_game_code generates valid JWT
  ‚òê get_sstoken validates signature correctly
  ‚òê get_sstoken rejects used codes
  ‚òê get_user_info returns accurate balance
  ‚òê change_balance updates balance correctly
  ‚òê change_balance rejects insufficient funds
  ‚òê Idempotency: same order_id returns same result
  ‚òê Concurrent requests don't corrupt balance

Security Testing:
  ‚òê Invalid signature rejected (1003 error)
  ‚òê Expired timestamp rejected
  ‚òê Reused code rejected (1001 error)
  ‚òê Expired ss_token rejected
  ‚òê Negative balance prevented

Integration Testing:
  ‚òê Complete game session from start to finish
  ‚òê Multiple bets in succession
  ‚òê Win/loss balance updates accurately
  ‚òê Purchase coins and walletUpdate works
  ‚òê Multiple games in same session


================================================================================
üöÄ PRODUCTION DEPLOYMENT NOTES
================================================================================

Before Going Live:

1. Change JWT Secret
   File: server/php/config.php
   Line: define('GAME_JWT_SECRET', 'your-secret-here');
   Action: Use strong random string (32+ chars)

2. Configure AppKey
   BAISHUN provides your AppKey
   Store in database: apps table
   Used for signature verification

3. Set Production URLs
   Update API_BASE_URL in Flutter app
   Point to production PHP server
   Enable HTTPS (required!)

4. Database Optimization
   Add indexes on:
   - users.user_id
   - sstokens.ss_token
   - used_codes.code
   - orders.order_id
   - orders.user_id

5. Enable Error Logging
   Log all signature failures
   Monitor used_codes table size
   Alert on high error rates

6. Performance Monitoring
   change_balance is high-volume
   Monitor database connection pool
   Consider read replicas for get_user_info

7. Backup Strategy
   Regular database backups
   orders table is critical (audit trail)
   Retain for compliance/disputes


================================================================================
üìö ADDITIONAL RESOURCES
================================================================================

Documentation Files:
  - docs/BAISHUN_game_settings.md
  - assets/BAISHUN_game_access.txt (full BAISHUN docs)
  - docs/POSTMAN_GAME_API_CHANGES.md

Code References:
  - lib/view/screens/room/room_screen.dart (frontend implementation)
  - server/php/*.php (backend endpoints)

BAISHUN Game IDs:
  1001 - Texas Hold'em
  1004 - Slots
  1005 - Joy Bounce
  1006 - Fishing
  (See assets/BAISHUN_game_access.txt for complete list)


================================================================================
‚úÖ CONCLUSION
================================================================================

This is a complete, production-ready game integration system that:
  ‚úì Securely authenticates users
  ‚úì Safely handles real-money transactions
  ‚úì Prevents double-charging and race conditions
  ‚úì Provides seamless WebView experience
  ‚úì Supports multiple games and languages
  ‚úì Follows BAISHUN specification exactly

The system is currently RUNNING and WORKING with all errors fixed!

For questions or issues, check:
  1. WebView console logs
  2. Backend PHP error logs
  3. Database transaction logs
  4. BAISHUN documentation in assets/

================================================================================
END OF DOCUMENT
================================================================================
